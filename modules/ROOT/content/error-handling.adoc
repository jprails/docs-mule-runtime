= Error Handling Reference
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: error handling, exceptions, exception catching, exceptions

Mule provides a series of scopes for handling errors.

When an activity in your Mule flow fails, Mule raises an error which you can handle inside an error handler scope. +
The Error Handler can enclose On Error scopes that you can implement to handle errors in your flow. All Mule applications have a default Error Handler for errors not defined in other on Error scopes.

From a high level perspective, errors that occur in Mule fall into one of two categories: system errors, and messaging errors.

== System Errors

Mule throws a system error when an exception occurs at the system level. +
If no Mule Event is involved, the errors are handled by a system error handler.

A system error handler handles exceptions that occur:

* During application start-up.
* When a connection to an external system fails.

When a system error occurs, Mule sends an error notification to registered listeners, logs the error, and if the error was caused by a connection failure, executes a reconnection strategy.

System error handlers are not configurable in Mule.

== Messaging Errors

Mule throws a messaging error whenever an exception is thrown within a flow. +
These errors are handled by the error handler scope.

When a Mule Event being processed through a Mule flow raises an error, normal flow execution stops and the process is transferred to the message processor sequence within the error handler scope. +
Inside the error handler scope you can incorporate various On Error scopes designed to match error types and expressions.  Within each on error scope that you configure, you can define an error path incorporating any number of event processors to handle the error precisely as you wish.

The diagram below illustrates what happens when an event processor raises an error.

image::error-handling-39be7.png[]

Mule supports three types of On Error Scopes. Each scope defines a different behavior for when an error occurs:

[%header%autowidth.spread]
|===
|On Error Scope |Description

| Default Error Handling
| Defined and implicitly applied by default to handle all messaging errors that are not handled by any On Error scopes. This is equivalent to an On Error Propagate with no child components for handling errors.

| On Error Continue
| If an error occurs within the Try scope, any other components in the scope are skipped, and execution continues immediately after the scope ends. +
If a transaction is being handled, it’s committed.

image::error-handling-f7bf0.png[]

| On Error Propagate
| If an error occurs within the Try scope, the error is propagated to the next level up and the execution of the entire flow breaks. As an exception, if the failing Try scope is nested within another Try scope with an On Error Continue, execution is continued outside the parent scope. +
If a transaction is being handled, it’s rolled back.

image:error-handling-e77ec.png[]
// COMBAK: On-Error retry not availabel for Beta
// | On Error Retry
// | If an error occurs within the Try scope, the entire scope is attempted again. +
// There can only be one On Error Retry scope in each Error Handler.
|===

Each On Error Scope can be set up to be triggered by a different set of error types. Both in Studio and Design Center, you can pick from a list of errors that could be raised by the components you placed inside the scope.

You can also set up a path to be triggered by type *ANY*, referring to all error types that aren't used by other paths. Note that conditions are evaluated in order, so for other paths to be evaluated, the *ANY* path must always be the last.

As an alternative to mapping a path to a set of error types, you can map it to a freely defined condition. For example, you can map a path to a condition by setting the When field to:

`#[error.cause.message.contains("fatal")]`

Each flow can contain only one error handler, however this error handler can contain as many On Error scopes as you see necessary.

////
Except for On Error Retry scope, only one of these is allowed per Error Handler block.
////

// COMBAK: Review reconnection strategies in Mozart
// == Reconnection Strategies
//
// Reconnection strategy behavior resembles that of error handling, but provides instructions specifically for reconnection attempts.

Within your flow, you can group a set of event processors that may throw an error inside a Try Scope. The Try Scope allows you enclose various event processors in your flow and assign it an Error Handler scope in case that operation may fail. +
You can also configure the operation inside the Try Scope to be processed as a transaction.


== Custom Error Mapping


In each operation component in your flow, you can map standard error types to a custom error type. You can use these custom error types to differentiate exactly where an error occurred in your flow. For example, if your flow has two HTTP Request connectors that reach out to different REST services, a connectivity error on either produces the same error message. By setting different custom error types for each, you can tell which of them failed from the error message.


== See Also

* xref:concepts/try-scope.adoc[About Try Scope]

* xref:reference/try-scope-xml.adoc[Try Scope XML Reference]

// COMBAK: Review reconnection strategies in Mozart
// * xref:about/reconnection-strategy.adoc[About Reconnection Strategies]