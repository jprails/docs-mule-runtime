= To Import DataWeave Modules
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

In DataWeave code, you can import additional components to extend the available functions. This may include additional modules that are packaged with Mule, such as the Crypto module, or custom built modules that may contain any predefined functions you want.


== Import a Modules

When you import a module, all of the functions an variables that the module includes become available to use in the DataWeave body.

In the example below, the module `MyModule` is imported in the header. Thanks to that, the function `myFunc` (that is packaged in that module) can be called, which adds an underscore at the end of the string.

.Example
[source,dataweave,linenums]
----
%dw 2.0
import myMods::MyModule
output application/json
---
MyModule::myFunc("dataweave")
----

.Output
[source,json,linenums]
----
"dataweave_"
----


In this case, the module that's being imported is stored in the path `myMods/MyModule.dwl` and contains the following:

.Example Module
[source,dataweave,linenums]
----
%dw 2.0
fun myfunc(name:String) = name ++ "_"
----


== Import an Element from a Module

You can choose to import only a specific element from a module, like a single function. This also helps you avoid typing the module name each time you refer to the element.

.Example
[source,dataweave,linenums]
----
%dw 2.0
import myFunc from myMods::MyModule
output application/json
---
myFunc("dataweave") ++ name
----

.Output
[source,json,linenums]
----
"dataweave_name"
----

In this case, the module that's being imported is stored in the path `myMods/MyModule.dwl` and contains the following:

.Example Module
[source,dataweave,linenums]
----
%dw 2.0
fun myfunc(name:String) = name ++ "_"
----

You can also invoke an element directly in the DataWeave body, without needing to import it in the header:

.Example
[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
myMods::MyModule::myFunc("dataweave") ++ name
----




== Import All Elements from a Module

As an alternative to importing the module, you can instead import all elements from the module. The advantage of this is that it then saves you from having to type the module name each time you refer to the element.


.Example
[source,dataweave,linenums]
----
%dw 2.0
import * from myMods::MyModule
output application/json
---
myFunc("dataweave") ++ myVar
----

.Output
[source,json,linenums]
----
"dataweave_name"
----

In this case, the module that's being imported is stored in the path `myMods/MyModule.dwl` and contains the following:

.Example Module
[source,dataweave,linenums]
----
%dw 2.0
fun myfunc(name:String) = name ++ "_"
var myVar = "Test"
----

== Assign a Local Alias for an Imported Element

You can assign an alternative alias to imported modules or elements from within them to avoid name clashes.

.Example
[source,dataweave,linenums]
----
%dw 2.0
import myFunc as appendDash, myVar as weaveName from myMods::MyModule
var myVar = "Mapping"
output application/json
---
appendDash("dataweave") ++ weaveName ++ "_" ++ myVar
----

.Output
[source,json,linenums]
----
"dataweave_name_Mapping"
----

You can also apply an alias to an imported module.

.Example
[source,dataweave,linenums]
----
%dw 2.0
import myMods::MyModule as WeaveMod
output application/json
---
WeaveMod::myFunc("dataweave")
----

.Output
[source,json,linenums]
----
"dataweave_"
----


In this case, the module that's being imported is stored in the path `myMods/MyModule.dwl` and contains the following:

.Example Module
[source,dataweave,linenums]
----
%dw 2.0
fun myfunc(name:String) = name ++ "_"
var myVar = "Test"
----


== Import a Mapping as a Function

When you import a .dwl file, its body is considered to be an additional function named `main`. This function expects an input that follows the structure of the input that the transformation uses.



.Example
[source,dataweave,linenums]
----
%dw 2.0
import myMods::MyMapping
output application/json
---
MyMapping::main({"payload": {foo: "bar"}}
----

.Output
[source,json,linenums]
----
{
    "foo": "bar"
}
----



In this case, the module that's being imported is stored in the path `myMods/MyMapping.dwl` and contains the following:


.Reusable Mapping
[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
{
  foo: payload.name
}
----

Note that there are no functions defined in this DataWeave code, yet the transformation described in the body is packaged as a function called `main`.

== See Also

* xref:dataweave/dataweave-create-module-task.adoc[To Create DataWeave Modules]
* xref:dataweave/dataweave-java-methods.adoc[To Call Java Methods]