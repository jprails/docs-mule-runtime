= To Create a DataWeave Module
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

You can encapsulate custom functions, variables, namespaces and types into reusable modules, which you can then import into any DataWeave code. This saves you from having to define these in the DataWeave header every time.

Modules are stored in regular .dwl files in your project folder, they use the same syntax as any other transformation file.

For example, below is a module you can import elsewhere. This module defines a function, a variable and a namespace. The body of the transformation is also packaged as a function called `main`. If the module is imported into another DataWeave file, all of these can be referenced as if they were declared in the header.

.Example
[source,dataweave,linenums]
----
%dw 2.0
fun myFunc(name: String) = name ++ " Test"
var data = "MyData"
ns mynamespace http://acme.com/bar
---
{
  foo: payload.name
}
----

You could for example store this in *myModules/MyModule.dwl* and then reference it on other files through `import myModules::MyModule`.


== See Also

* xref:dataweave/dataweave-import-task.adoc[To Import a DataWeave Module]
* xref:dataweave/dataweave-java-methods.adoc[To Call Java Methods]